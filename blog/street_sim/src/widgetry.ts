// TODO: we want this to be dynamic, or parameterized or something
// Tricky because the contents of this include the imports which have a bunch
// of dynamic symbols (I think generated by wasm_bindgen)
// import { default as init } from './boot.js'
import { default as init, run_in_dom_element } from './pkg/widgetry_demo.js'

export class WidgetryConfig {
   wasmURL: URL;

   public constructor() {
        //this.wasmURL = new URL('http://abstreet.s3-website.us-east-2.amazonaws.com/dev/game/game_bg.wasm');
        this.wasmURL = new URL('http://localhost:4000/js/pkg/widgetry_demo_bg.wasm');
   } 

   public wasmURLString() {
       return this.wasmURL.toString()
   }
}

export enum AppLoadState {
    unloaded, loading, loaded, error
}

export class WidgetryApp {
    el: HTMLElement;
    domId: string;
    config: WidgetryConfig;
    state: AppLoadState = AppLoadState.unloaded;

    public constructor(domId: string) {
        this.domId = domId;
        let el = document.getElementById(domId);
        if (el === null) {
            throw new Error(`element with domId: ${domId} not found`);
        }
        this.el = el;
        appendLoading(this.el);
        this.config = new WidgetryConfig();
        this.render();

        console.log("sim constructor", this);
    }

    public async loadAndStart() {
        try {
            await this.load();
            await this.start();
        } catch (e) {
            if (e.toString() == "Error: Using exceptions for control flow, don't mind me. This isn't actually an error!") {
                // This is an expected, albeit unfortunate, control flow mechanism for winit on wasm.
                console.debug("ignoring expected error:", e);
            } else {
                console.error("error while loading: ", e);
                this.updateState(AppLoadState.error);
                alert(e);
            }
        }
    }

    async load() {
        console.assert(this.state == AppLoadState.unloaded, "already loaded");
        // TODO: copy incremental loading logic from ABStreet for progress indication
        let response: Response = await fetch(this.config.wasmURLString());
        this.updateState(AppLoadState.loading);

        // TODO: Prefer streaming instantiation where available (not safari)? Seems like it'd be faster.
        // const { instance } = await WebAssembly.instantiateStreaming(response, imports);
        
        let blob: Blob = await response.blob();
        let bytes: ArrayBuffer = await blob.arrayBuffer();
        //let imports = {};
        //let instance = await WebAssembly.instantiate(bytes, imports);
        let widgetry = await init(bytes);

        run_in_dom_element(this.domId);

        this.updateState(AppLoadState.loaded);
    }

    async start() {
        console.assert(this.state == AppLoadState.loaded, "not yet loaded");
        // TODO - actually do something
        console.log("sim starting");
    }

    updateState(newValue: AppLoadState) {
        console.debug(`state change: ${AppLoadState[this.state]} -> ${AppLoadState[newValue]}`);
        this.state = newValue;
        this.render();
    }

    render() {
        this.el.style["border-style"] = "solid";
        this.el.style["border-thickness"] = "4px";
        this.el.style["border-color"] = ((): string => {
            switch (this.state) {
                case AppLoadState.unloaded: return "yellow";
                case AppLoadState.loading: return "green";
                case AppLoadState.loaded: return "white";
                case AppLoadState.error: return "red";
            }
        })();
    }
}

function appendLoading(el) {
    let loadingEl = document.createElement("p");
    let text = document.createTextNode("Loading...");
    loadingEl.append(text);
    loadingEl.id = "loading";

    el.append(loadingEl);
}
